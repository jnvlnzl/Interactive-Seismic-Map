# -*- coding: utf-8 -*-
"""ph_map.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OBjqVeYwuyLAAbvdKt_B-ggGZ6roC8kI

# Final Project: Map

## Import libraries
"""

from datetime import datetime

import os
import pandas as pd
import geopandas as gpd
import json
import numpy as np

import plotly.express as px
import plotly.graph_objects as go

import dash
from dash import dcc, html, State

import dash_daq as daq

import dash.dependencies as dd
from dash.dependencies import Input, Output

import traceback

"""## Import datasets for province shapes, active fault lines, and magnitude with population"""



gdf_ph_provinces = gpd.read_file("data/ph_provinces.geojson")
active_faults = gpd.read_file("data/gem_active_faults.geojson")
magnitude_df = pd.read_csv("data/[POP] FINAL_merged_earthquake_data.csv")

"""### Processing datasets

Processing dataframe for fault lines
"""

ph_faults = active_faults[active_faults["catalog_name"].str.contains("Philippines", case=False)]
# print(ph_faults[["catalog_name", 'name', "geometry"]].head())

"""Added columns to simplify bubble map charting"""

magnitude_df['Date'] = pd.to_datetime(magnitude_df['Date'])
magnitude_df['Year_Earthquake'] = magnitude_df['Date'].dt.year

# print(magnitude_df.head())

"""Compute average magnitude of earthquakes per province to improve for chloropleth mapping"""

magnitude_gdf = gpd.GeoDataFrame(
    magnitude_df, geometry=gpd.points_from_xy(magnitude_df["Longitude"], magnitude_df["Latitude"]), crs="EPSG:4326"
)

# Calculate average magnitude per province
magnitude_gdf = gpd.sjoin(magnitude_gdf, gdf_ph_provinces, how="left", predicate="intersects")
province_ave_magnitudes = magnitude_gdf.groupby("adm2_en")["Magnitude"].mean().reset_index()
# print(province_ave_magnitudes.head())

"""Create dataframe for population data"""

magnitude_df["2000"] = magnitude_df["2000"].replace({',': ''}, regex=True).astype(int)

# for Populations
pop_columns = ["Province", "2020", "2015", "2010", "2000"]
population_df = magnitude_df[pop_columns].drop_duplicates("Province")
# print(population_df.head())

"""Data preparation for line chart"""

try:
    magnitude_df['Date'] = pd.to_datetime(magnitude_df['Date'])
    magnitude_df['Year'] = magnitude_df['Date'].dt.year

    grouping_cols = ['Year', 'Province', 'Region', 'Island Group']
    if all(col in magnitude_df.columns for col in grouping_cols):
        earthquake_counts = magnitude_df.groupby(grouping_cols).size().reset_index(name='Number of Earthquakes')
        overall_counts = magnitude_df.groupby('Year').size().reset_index(name='Number of Earthquakes')

        provinces = sorted(earthquake_counts['Province'].dropna().unique())
        regions = sorted(earthquake_counts['Region'].dropna().unique())
        island_groups = sorted(earthquake_counts['Island Group'].dropna().unique())
        if 'Year' in earthquake_counts.columns and not earthquake_counts.empty:
             min_year = int(earthquake_counts['Year'].min())
             max_year = int(earthquake_counts['Year'].max())
             available_years = sorted(earthquake_counts['Year'].unique())
        else:
             raise ValueError("'Year' column not found or empty in earthquake_counts")
    else:
        missing_cols = [col for col in grouping_cols if col not in magnitude_df.columns]
        raise ValueError(f"Missing required columns for line chart aggregation: {missing_cols}")

except Exception as e:
    # print(f"FATAL ERROR preparing data for line chart explorer: {e}. Assigning defaults.")
    earthquake_counts = pd.DataFrame()
    overall_counts = pd.DataFrame()
    provinces, regions, island_groups = [], [], []
    min_year, max_year = datetime.now().year - 10, datetime.now().year
    available_years = list(range(min_year, max_year + 1))

"""## Visualization"""

magnitude_ranges = [
    None, (1.0, 1.9), (2.0, 2.9), (3.0, 3.9), (4.0, 4.9),
    (5.0, 5.9), (6.0, 6.9), (7.0, 7.9), (8.0, 8.9)]

magnitude_labels = [
    "All", "Micro (1.0-1.9)", "Minor (2.0–2.9)", "Minor (3.0-3.9)", "Light (4.0–4.9)",
    "Moderate (5.0–5.9)", "Strong (6.0–6.9)", "Major (7.0–7.9)", "Great (8.0-8.9)"]

magnitude_colors = ["#FFE500", "#FFC400", "#FFA400", "#FF8300",
                    "#FF6200", "#FF4100", "#FF2100", "#FF0000"]

app = dash.Dash(__name__,
                external_stylesheets=["assets/style.css"],
                suppress_callback_exceptions=True) # Important for dynamic layouts
server = app.server

min_year, max_year = 2000, datetime.now().year # Default fallbacks
if 'Year_Earthquake' in magnitude_df.columns:
    min_yr_val = magnitude_df['Year_Earthquake'].min()
    max_yr_val = magnitude_df['Year_Earthquake'].max()
    if pd.notna(min_yr_val): min_year = int(min_yr_val)
    if pd.notna(max_yr_val): max_year = int(max_yr_val)

app.layout = html.Div([
    # Main controls
    html.Div(id='main-controls', style={'display': 'block'}, children=[
        html.Label("Select Average Earthquake Magnitude Range"),
        html.Div(
            dcc.Slider(id="magnitude-slider",
                       min=0, max=len(magnitude_ranges) - 1, value=0, step=1,
                       marks={ i: {"label": magnitude_labels[i].replace(" ", "\\n"), "style": {"white-space": "pre-line"}} for i in range(len(magnitude_ranges)) },
                       className="colored-slider"
            ),
            style={"margin-bottom": "15px"}
        ),
        html.Div([html.Label("Show Fault Lines", style={"margin-right": "10px"}), daq.ToggleSwitch(id="fault-toggle", value=True, color="#333")],
                 style={"display": "flex", "alignItems": "center", "margin-bottom": "20px"}),
    ]),

    # Main map (choropleth map)
    html.Div(id='main-map-container', style={'display': 'block', 'height': '75vh'}, children=[
        dcc.Loading(id="loading-main-map", children=dcc.Graph(id="earthquake-map", style={'height': '100%'}))
    ]),

    # Detail map (bubble map + line chart)
    html.Div(id='detail-view-container', style={'display': 'none', 'flexDirection': 'row', 'height': '85vh'}, children=[
        html.Div(id='bubble-map-wrapper', style={'flex': '2', 'paddingRight': '10px', 'display': 'flex', 'flexDirection': 'column'}, children=[
             html.H3(id="province-title", style={'textAlign': 'center', 'flexShrink': 0}),
             html.Label("Filter Bubble Map by Year:", style={'flexShrink': 0, 'marginLeft': '15px'}),
             html.Div(
                 dcc.RangeSlider(
                     id="bubble-year-slider", min=min_year, max=max_year, value=[min_year, max_year], step=1,
                     marks={str(year): str(year) for year in available_years},
                 ),
                 style={'margin': '0 15px 15px 15px', 'flexShrink': 0}
             ),
             dcc.Loading(id="loading-bubble-map", children=dcc.Graph(id="bubble-map", style={'flexGrow': 1, 'minHeight': 0}))
        ]),

        html.Div(id='line-chart-explorer-wrapper', style={'flex': '3', 'display': 'flex', 'borderLeft': '1px solid #ccc'}, children=[
            html.Div([
                html.H4("Options:", style={'marginTop':'0px'}),
                dcc.Checklist(
                    id="line-chart-overall-toggle",
                    options=[ {"label": "Overall Earthquakes", "value": "overall"}, {"label": "Overall Provinces", "value": "overall_provinces"}, {"label": "Overall Regions", "value": "overall_regions"}, {"label": "Overall Island Groups", "value": "overall_island_groups"} ],
                    value=["overall"]),
                html.Br(), html.Label("Sort by:"), html.Br(), html.Br(),
                dcc.Dropdown(
                    id="line-chart-filter-type",
                    options=[ {"label": "Province", "value": "Province"}, {"label": "Region", "value": "Region"}, {"label": "Island Group", "value": "Island Group"} ],
                    placeholder="Select Filter Type"),
                html.Div(id="line-chart-filter-selector-container", children=[
                    dcc.Checklist(id="line-chart-filter-selector", value=[])
                ], style={"display": "none", "maxHeight": "250px", "overflowY": "scroll"}),
            ], style={"width": "250px", "overflowY": "auto", "borderRight": "1px solid #ccc", "padding": "10px", "flexShrink": 0, "backgroundColor": "#f9f9f9"}),

            html.Div([
                html.Label("Select Year Range:", style={'marginLeft': '15px'}),
                 html.Div(
                    dcc.RangeSlider(
                        id="line-chart-year-slider", min=min_year, max=max_year, step=None,
                        value=[min_year, max_year],
                        marks={str(year): str(year) for year in available_years},
                    ),
                    style={'margin': '0 15px 15px 15px'}
                 ),
                html.Br(),
                dcc.Loading(id='loading-line-chart-explorer', children=dcc.Graph(id="line-chart-graph"))
            ], style={"flexGrow": 1, 'display': 'flex', 'flexDirection': 'column'})
        ]),
    ]),

    html.Button("Back to Main Map", id="back-button", className="back-button-styled", style={"display": "none", 'marginTop': '15px'}),
    html.Div(id="click-data", style={"display": "none"}),
])


# Callback to update the main Choropleth Map
@app.callback(
    Output("earthquake-map", "figure"),
    [Input("magnitude-slider", "value"),
     Input("fault-toggle", "value")]
)
def update_map(idx, fault_toggle):
    # Default values in case of issues
    choro_data = pd.DataFrame()
    color_scale = px.colors.sequential.YlOrRd # Default scale
    range_color = [1, 5] # Default range
    show_scale_bar = False
    fig = go.Figure() # Initialize empty figure

    # Validate index
    if idx < 0 or idx >= len(magnitude_ranges):
        fig.update_layout(title="Error: Invalid magnitude selection")
        return fig # Return empty fig with error

    # Prepare data for choropleth based on slider
    if magnitude_ranges[idx] is None: # "All" selected
        if province_ave_magnitudes is None or province_ave_magnitudes.empty:
            fig.update_layout(title="Error: Missing average magnitude data")
            return fig
        choro_data = province_ave_magnitudes.copy()
        color_scale = px.colors.sequential.YlOrRd
        if 'Magnitude' in choro_data.columns and not choro_data['Magnitude'].isnull().all():
             range_color = [choro_data['Magnitude'].min(), choro_data['Magnitude'].max()]
        show_scale_bar = True
    else: # Specific magnitude range selected
        if province_ave_magnitudes is None or province_ave_magnitudes.empty:
            fig.update_layout(title="Error: Missing average magnitude data")
            return fig
        min_mag, max_mag = magnitude_ranges[idx]
        choro_data = province_ave_magnitudes[
            (province_ave_magnitudes["Magnitude"] >= min_mag) &
            (province_ave_magnitudes["Magnitude"] <= max_mag)
        ].copy()
        if idx - 1 >= 0 and idx - 1 < len(magnitude_colors):
             single_color = magnitude_colors[idx - 1]
        else:
             single_color = "#CCCCCC" # Default grey if color index is bad
        color_scale = [[0, single_color], [1, single_color]]
        range_color = [min_mag, max_mag]
        show_scale_bar = False

    # Handle empty selection for specific ranges
    if choro_data.empty and magnitude_ranges[idx] is not None:
         fig.update_layout(title=f"No provinces with average magnitude {magnitude_labels[idx]}")
         return fig

    # Merge population data for hover info
    custom_data_array = np.array([[]]) # Initialize empty
    pop_cols = ["2020", "2015", "2010", "2000"]
    hover_template_pop = "Population data unavailable<extra></extra>"
    if population_df is not None and not population_df.empty and 'Province' in population_df.columns and 'adm2_en' in choro_data.columns:
        choro_data = choro_data.merge(population_df, left_on="adm2_en", right_on="Province", how="left")
        # Ensure all pop columns exist before creating customdata
        for col in pop_cols:
            if col not in choro_data:
                choro_data[col] = 0 # Add column with 0 if missing after merge
        custom_data_array = choro_data[pop_cols].fillna(0).values
        hover_template_pop = ("Pop (2020): %{customdata[0]:,}<br>" +
                              "Pop (2015): %{customdata[1]:,}<br>" +
                              "Pop (2010): %{customdata[2]:,}<br>" +
                              "Pop (2000): %{customdata[3]:,}<extra></extra>")

    # Add Choropleth trace if data exists
    if not choro_data.empty and 'adm2_en' in choro_data.columns and 'Magnitude' in choro_data.columns:
        fig.add_trace(go.Choroplethmapbox(
            geojson=gdf_ph_provinces.__geo_interface__,
            locations=choro_data["adm2_en"],
            z=choro_data["Magnitude"],
            featureidkey="properties.adm2_en",
            colorscale=color_scale,
            zmin=range_color[0], zmax=range_color[1],
            marker_opacity=0.7, marker_line_width=0.5,
            showscale=show_scale_bar,
            colorbar_title="Avg Magnitude" if show_scale_bar else "",
            customdata=custom_data_array,
            hovertemplate=(
                "<b>%{location}</b><br>" +
                "Average Magnitude: %{z:.2f}<br>" +
                hover_template_pop
            )
        ))

    # Overlay fault lines if toggled and data exists
    if fault_toggle and ph_faults is not None and not ph_faults.empty and 'geometry' in ph_faults.columns and 'name' in ph_faults.columns:
        for _, row in ph_faults.iterrows():
            fault_geometry = row.geometry
            fault_name = row['name'] if pd.notna(row['name']) else "Unnamed Fault" # Handle potential null names
            if fault_geometry is None or fault_geometry.is_empty: continue

            lines_to_plot = []
            if fault_geometry.geom_type == 'LineString':
                lines_to_plot = [fault_geometry]
            elif fault_geometry.geom_type == 'MultiLineString':
                lines_to_plot = list(fault_geometry.geoms)

            for line in lines_to_plot:
                 if line is None or line.is_empty: continue
                 lon, lat = line.xy
                 fig.add_trace(go.Scattermapbox(
                    lat=list(lat), lon=list(lon),
                    mode='lines', line=dict(color='black', width=2),
                    name="Fault Line",
                    text=f"<b>Fault:</b> {fault_name}",
                    hoverinfo='text',
                    showlegend=False
                 ))

    # Update Layout
    fig.update_layout(
        mapbox_style="carto-positron",
        mapbox_zoom=4.5,
        mapbox_center={"lat": 12.8797, "lon": 121.7740},
        margin={"r": 0, "t": 0, "l": 0, "b": 0},
        clickmode='event+select'
    )

    return fig

# Callback to handle clicks on the main map -> Show Bubble Map
@app.callback(
    Output("main-map-container", "style", allow_duplicate=True),
    Output("main-controls", "style", allow_duplicate=True),
    Output("detail-view-container", "style", allow_duplicate=True),
    Output("back-button", "style", allow_duplicate=True),
    Output("click-data", "children", allow_duplicate=True),
    Output("province-title", "children", allow_duplicate=True),
    Output("line-chart-filter-type", "value", allow_duplicate=True),
    Output("line-chart-filter-selector", "value", allow_duplicate=True),
    Input("earthquake-map", "clickData"),
    prevent_initial_call=True
)
def handle_map_click(clickData):
    if clickData is None or not clickData.get('points'):
        return [dash.no_update] * 8
    try:
         clicked_province_map_key = clickData['points'][0].get('location')
         if clicked_province_map_key is None: return [dash.no_update] * 8

         # --- Adjust key mapping if needed ---
         clicked_province_select_key = clicked_province_map_key

         main_map_style = {"display": "none"}
         main_controls_style = {"display": "none"}
         detail_view_style = {"display": "flex"}
         back_button_style = {"display": "block"}
         province_title_bubble = f"Details for: {clicked_province_map_key}"
         click_data_store = clicked_province_map_key
         line_chart_filter_type_init = "Province"
         line_chart_filter_selector_init = [clicked_province_select_key]

         return (main_map_style, main_controls_style, detail_view_style, back_button_style,
                 click_data_store, province_title_bubble,
                 line_chart_filter_type_init, line_chart_filter_selector_init)
    except Exception as e:
         traceback.print_exc()
         return [dash.no_update] * 8

# Callback to update the Bubble Map based on clicked province and year slider
@app.callback(
    Output("bubble-map", "figure"),
    Input("click-data", "children"),
    Input("bubble-year-slider", "value")
)
def update_bubble_map(clicked_province, year_range):
    # Initialize empty figure
    fig_bubble = go.Figure(layout={"template": "plotly_white"})

    # Check if province is selected
    if not clicked_province:
        fig_bubble.update_layout(title="Select a province on the main map")
        return fig_bubble

    # Check if year range is valid
    if not isinstance(year_range, (list, tuple)) or len(year_range) != 2:
         fig_bubble.update_layout(title="Error: Invalid year range")
         return fig_bubble

    # Ensure required columns exist in earthquake data
    required_cols = ["Province", "Year_Earthquake", "Latitude", "Longitude", "Magnitude", "Location", "Depth_In_Km", "Date"]
    if not all(col in magnitude_df.columns for col in required_cols):
         fig_bubble.update_layout(title="Error: Missing required earthquake data columns")
         return fig_bubble

    # Filter the main earthquake dataframe
    filtered_eq = magnitude_df[
        (magnitude_df["Province"].astype(str).str.strip() == str(clicked_province).strip()) &
        (magnitude_df["Year_Earthquake"] >= year_range[0]) &
        (magnitude_df["Year_Earthquake"] <= year_range[1])
    ].copy()

    # Handle case of no earthquakes found
    if filtered_eq.empty:
         fig_bubble.update_layout(title=f"No recorded earthquakes in {clicked_province} ({year_range[0]}-{year_range[1]})")
         return fig_bubble

    # Get province geometry for centering
    center_lat, center_lon, zoom_level = 12.8797, 121.7740, 6 # Defaults
    if gdf_ph_provinces is not None and 'adm2_en' in gdf_ph_provinces.columns and 'geometry' in gdf_ph_provinces.columns:
        province_geo_series = gdf_ph_provinces[gdf_ph_provinces["adm2_en"] == clicked_province].geometry
        if not province_geo_series.empty:
             province_geom = province_geo_series.iloc[0]
             if province_geom and not province_geom.is_empty:
                 bounds = province_geom.bounds # This returns a tuple (minx, miny, maxx, maxy)
                 center_lon = (bounds[0] + bounds[2]) / 2 # Use index 0 for minx, 2 for maxx
                 center_lat = (bounds[1] + bounds[3]) / 2 # Use index 1 for miny, 3 for maxy
                 zoom_level = 8 # Reset zoom for specific province

    # Create the scatter mapbox figure if filtered data exists
    fig_bubble = px.scatter_mapbox(
        filtered_eq,
        lat="Latitude", lon="Longitude",
        size="Magnitude", color="Magnitude",
        color_continuous_scale=px.colors.sequential.Reds,
        size_max=15,
        hover_name="Location",
        hover_data={
             "Magnitude": ":.1f", "Depth_In_Km": ":.1f km", "Date": "|%Y-%m-%d",
             "Province": True, "Latitude": False, "Longitude": False
        },
        custom_data=['Date'] # Keep if needed for future interactions
    )

    # Update layout for bubble map
    fig_bubble.update_layout(
        mapbox_style="carto-positron",
        mapbox_center={"lat": center_lat, "lon": center_lon},
        mapbox_zoom=zoom_level,
        margin={"r": 0, "t": 40, "l": 0, "b": 0},
        title=f"Earthquakes in {clicked_province} ({year_range[0]}-{year_range[1]})",
        legend_title_text='Magnitude'
    )

    return fig_bubble


# Callback for the Back Button -> Show Main Map
@app.callback(
    Output("main-map-container", "style", allow_duplicate=True),
    Output("main-controls", "style", allow_duplicate=True),
    Output("detail-view-container", "style", allow_duplicate=True),
    Output("back-button", "style", allow_duplicate=True),
    Output("click-data", "children", allow_duplicate=True),
    Output("line-chart-overall-toggle", "value", allow_duplicate=True),
    Output("line-chart-filter-type", "value", allow_duplicate=True),
    Output("line-chart-filter-selector", "value", allow_duplicate=True),
    Output("line-chart-year-slider", "value", allow_duplicate=True),
    Input("back-button", "n_clicks"),
    prevent_initial_call=True
)
def go_back_to_main_map(n_clicks):
    if n_clicks is None: return [no_update] * 9
    try:
        line_chart_overall_reset = ["overall"]
        line_chart_filter_type_reset = None
        line_chart_filter_selector_reset = []
        line_chart_year_slider_reset = [min_year, max_year]
        main_map_style = {"display": "block"}
        main_controls_style = {"display": "block"}
        detail_view_style = {"display": "none"}
        back_button_style = {"display": "none"}
        click_data_store = None

        return (main_map_style, main_controls_style, detail_view_style, back_button_style,
                click_data_store, line_chart_overall_reset, line_chart_filter_type_reset,
                line_chart_filter_selector_reset, line_chart_year_slider_reset)
    except Exception as e:
        traceback.print_exc()
        return [dash.no_update] * 9


# Callback to update the main line chart graph
@app.callback(
    Output("line-chart-filter-selector-container", "style"),
    Output("line-chart-filter-selector", "options"),
    Input("line-chart-filter-type", "value")
)
def update_line_chart_checklist(filter_type):
    options = []
    style = {"display": "none"}
    if filter_type == "Province":
        options = [{"label": p, "value": p} for p in provinces]
        if options: style = {"display": "block"}
    elif filter_type == "Region":
        options = [{"label": r, "value": r} for r in regions]
        if options: style = {"display": "block"}
    elif filter_type == "Island Group":
        options = [{"label": i, "value": i} for i in island_groups]
        if options: style = {"display": "block"}
    return style, options


@app.callback(
    Output("line-chart-graph", "figure"),
    Input("line-chart-filter-selector", "value"),
    Input("line-chart-filter-type", "value"),
    Input("line-chart-overall-toggle", "value"),
    Input("line-chart-year-slider", "value")
)
def update_line_chart_explorer_graph(selected_values, filter_type, overall_toggle, year_range):
    if earthquake_counts.empty or overall_counts.empty:
         return go.Figure(layout={"title": "Data unavailable", "template": "plotly_white"})

    try:
        start_year, end_year = year_range
        filtered_ec = earthquake_counts[ (earthquake_counts['Year'] >= start_year) & (earthquake_counts['Year'] <= end_year) ]
        filtered_oc = overall_counts[ (overall_counts['Year'] >= start_year) & (overall_counts['Year'] <= end_year) ]

        fig = go.Figure()
        fig.update_layout(
            title="Earthquake Trends Explorer",
            xaxis_title="Year", yaxis_title="Number of Earthquakes",
            template="plotly_white", margin=dict(l=40, r=20, t=60, b=40),
            xaxis=dict( tickmode='array', tickvals=available_years, ticktext=[str(year) for year in available_years], range=[start_year - 0.5, end_year + 0.5] )
        )
        traces_added = False

        if "overall" in overall_toggle and not filtered_oc.empty:
            fig.add_trace(go.Scatter(x=filtered_oc["Year"], y=filtered_oc["Number of Earthquakes"], mode="lines", name="Overall Earthquakes", line=dict(dash="dot")))
            traces_added = True
        if "overall_provinces" in overall_toggle:
            prov_agg = filtered_ec.groupby(['Year', 'Province'])['Number of Earthquakes'].sum().reset_index()
            for province in provinces:
                province_data = prov_agg[prov_agg['Province'] == province]
                if not province_data.empty:
                    fig.add_trace(go.Scatter(x=province_data["Year"], y=province_data["Number of Earthquakes"], mode="lines", name=province))
                    traces_added = True
        if "overall_regions" in overall_toggle:
             reg_agg = filtered_ec.groupby(['Year', 'Region'])['Number of Earthquakes'].sum().reset_index()
             for region in regions:
                region_data = reg_agg[reg_agg['Region'] == region]
                if not region_data.empty:
                    fig.add_trace(go.Scatter(x=region_data["Year"], y=region_data["Number of Earthquakes"], mode="lines", name=region))
                    traces_added = True
        if "overall_island_groups" in overall_toggle:
             ig_agg = filtered_ec.groupby(['Year', 'Island Group'])['Number of Earthquakes'].sum().reset_index()
             for ig in island_groups:
                ig_data = ig_agg[ig_agg['Island Group'] == ig]
                if not ig_data.empty:
                    fig.add_trace(go.Scatter(x=ig_data["Year"], y=ig_data["Number of Earthquakes"], mode="lines", name=ig))
                    traces_added = True

        if selected_values and filter_type:
            filtered_data_specific = filtered_ec[filtered_ec[filter_type].isin(selected_values)]
            if not filtered_data_specific.empty:
                 if filter_type in ["Region", "Island Group"]:
                     grouped_data = filtered_data_specific.groupby(['Year', filter_type])['Number of Earthquakes'].sum().reset_index()
                     for item in selected_values:
                         subset = grouped_data[grouped_data[filter_type] == item]
                         if not subset.empty:
                              fig.add_trace(go.Scatter(x=subset["Year"], y=subset["Number of Earthquakes"], mode="lines+markers", name=item))
                              traces_added = True
                 else:
                     prov_select_agg = filtered_data_specific.groupby(['Year', 'Province'])['Number of Earthquakes'].sum().reset_index()
                     for item in selected_values:
                        subset = prov_select_agg[prov_select_agg[filter_type] == item]
                        if not subset.empty:
                             fig.add_trace(go.Scatter(x=subset["Year"], y=subset["Number of Earthquakes"], mode="lines+markers", name=item))
                             traces_added = True

        if not traces_added:
             fig.update_layout(title="Select options or adjust year range to view trends")

        return fig

    except Exception as e:
        traceback.print_exc()
        return go.Figure(layout={"title": "Error generating line chart", "template": "plotly_white"})


# --- Run the App ---
# if __name__ == "__main__":
#     # When running in Colab:
#     # app.run(mode='inline', port=8050, debug=True) # Keep debug=True for development feedback
#     # When running locally:
#     # app.run_server(debug=True, port=8050)
#     app.run(debug=False, host='0.0.0.0', port=8050)

if __name__ == "__main__":
    app.run(debug=True)

# if __name__ == "__main__":
#     port = int(os.environ.get("PORT", 8050))
#     app.run(host="0.0.0.0", port=port, debug=False)